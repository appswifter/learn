<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jarvis March</title>
  <!-- 借鉴SelectionSort的思想, 每次选择最大的元素归到有序部分, 在这我们就可能可以缩小下一个候选者的范围, 每次可以沿着构造出来
      边的端点向后继续找到extreme edge 
    -->
    
  <style>
    html, body { height: 100%; }
    body {
      background: black;
      
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    canvas {
      background: #fff;

    }
  </style>
</head>
<body>
  <canvas id='canvas' width="500" height="500"></canvas>
  <button id='button2'>添加</button>
  <button id='button'>开始</button>
  <script>
    const canvas = document.getElementById('canvas')

    const context = canvas.getContext('2d');

    let points = []

    const polygons = []

    canvas.onmousedown = function(ev) {
      var x = ev.clientX,
          y = ev.clientY
        var rect = ev.target.getBoundingClientRect()
        x = ((x - rect.left));
        y = (y - rect.top);
        points.push({
          x,
          y,
          succ: null,
          extreme: false
        });


        draw()
    }

    document.getElementById('button').onclick = compute

    document.getElementById('button2').onclick = add

    function draw() {
      
      context.clearRect(0, 0, canvas.width, canvas.height);
      let linePoint
      let index = 1
      for (let point of points) {
        if (point.extreme) { linePoint = point; }
        context.beginPath()
        context.fillStyle = point.extreme ? "blue" : "black"
        context.arc(point.x, point.y, 5, 0, Math.PI * 2, true)
        context.closePath()
        context.fill()
        context.fillStyle = "white"
        context.fillText(`${index}`, point.x - 3, point.y + 3)
        index++
      }

      for (let polygon of polygons) {
        let temp = polygon
        index = 1
        do {
          let point = temp;
          const [p, q] = [temp, temp.succ]
          context.beginPath()
          context.fillStyle = point.extreme ? "blue" : "black"
          context.arc(p.x, p.y, 5, 0, Math.PI * 2, true)
          context.closePath()
          context.fill()

          context.beginPath()
          context.moveTo(p.x, p.y)
          context.lineTo(q.x, q.y)
          context.closePath()
          context.stroke()


          context.fillStyle = "black"
          context.fillText(`${index}`, (p.x + q.x)/2, (p.y+q.y)/2 + 3)
          temp = temp.succ
          index++
        } while(temp !== polygon)
      }
    
    }

    function add() {
      points.forEach(point => point.extreme = false)

      let ltl = LTL(points)
      let kpoint = ltl

      do {
        kpoint.extreme = true
        let s = -1
        for (let t = 0; t < points.length; t ++) {
          if (points[t] !== kpoint && points[s] !== kpoint && (s === -1 || !ToLeft(kpoint, points[s], points[t]))) {
            s = t
          }
        }
        kpoint.succ = points[s]
        kpoint = points[s]
        
      } while (ltl !== kpoint)
      
      polygons.push(ltl)
      points = []

      draw()
    }

    function cross(a, b) {
      return a[0] * b[1] - b[0] * a[1]
    }

    function compute() {
      // Let E/F be the destination endpoint of e / f. Then
      // 1) if F ∉ L(e) and e x f > 0, or F ∈ L(e) and e x f < 0, advance f
      // 2) if E ∈ L(f) and f x e > 0, or E ∈ L(f) and f x e < 0, advance e

      let startE = polygons[0]
      let startF = polygons[1]

      let tempE = startE
      let tempF = startF

      do {

        let E = tempE.succ
        let F = tempF.succ

        let e = [E.x - tempE.x, E.y - tempE.y]
        let f = [F.x - tempF.x, F.y - tempF.y]

        let LF = ToLeft(tempE, E, F) // F ∈ L(e) 

        let LE = ToLeft(tempF, F, E) // E ∈ L(f)

        if (ToLeft(tempE, E, F) !== ToLeft(tempE, E, tempF) && ToLeft(tempF, F, E) !== ToLeft(tempF, F, tempE)) {
          console.log('交点')
        }

        console.log(LF, LE, cross(e, f), cross(f, e), (!LF && cross(e, f) > 0) || (LF && cross(e, f) < 0), (!LE && cross(f, e) > 0) || (LE && cross(f, e) < 0))

        if ((!LF && cross(e, f) > 0) || (LF && cross(e, f) < 0)) {
          tempF = tempF.succ
        } 
        
        if ((!LE && cross(f, e) > 0) || (LE && cross(f, e) < 0)) {
          tempE = tempE.succ
        } 


      } while (startE !== tempE)
    }

    function LTL(points) {
      let minPoint = null

      for (let point of points) {
        if (!minPoint || point.y <= minPoint.y) {
          minPoint = point

          if (minPoint.x < point.x) {
            minPoint = point
          } 
        }
      }

      return minPoint
    }

    function ToLeft(p, q, s) {
      return area(p, q, s) < 0
    }

    /**
     *      | p.x p.y 1 |
     * 2S = | q.x q.y 1 |
     *      | s.x s.y 1 |
     */
    function area(p, q, s) {
      return p.x * q.y - p.x * s.y - p.y * q.x + p.y * s.x + q.x * s.y - q.y * s.x
    }
  </script>
</body>
</html>